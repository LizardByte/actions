/**
 * Changelog generation script for GitHub Actions
 * This script fetches all releases and generates a CHANGELOG.md file.
 */

/**
 * Format a date as YYYY-MM-DD
 * @param {Date} date - Date object to format
 * @returns {string} Formatted date string
 */
function formatDate(date) {
  const year = date.getFullYear();
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  const day = date.getDate().toString().padStart(2, '0');
  return `${year}-${month}-${day}`;
}

/**
 * Transform release body markdown headers
 * @param {string} body - Release body text
 * @returns {string} Transformed body text
 */
function transformReleaseBody(body) {
  // Replace lines such as `## Any Text\n` with `### Any Text\n`
  return body.replaceAll(/## (.*)\n/g, '### $1\n');
}

/**
 * Generate changelog header
 * @returns {string} Changelog header
 */
function generateChangelogHeader() {
  let changelogHeader = '<!-- # Changelog -->\n\n';  // commenting out due to how sphinx renders this
  changelogHeader += 'All notable changes to this project will be documented in this file.\n\n';
  changelogHeader += 'The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\n';
  changelogHeader += 'and this project adheres to [Calendar Versioning](https://calver.org/).\n\n';
  changelogHeader += 'This changelog was automatically generated by the\n';
  changelogHeader += 'LizardByte [release_changelog](https://github.com/LizardByte/actions) action.\n\n';
  return changelogHeader;
}

/**
 * Generate changelog body from releases
 * @param {Array} releases - Array of release objects
 * @returns {string} Changelog body
 */
function generateChangelogBody(releases) {
  let changelogBody = '';

  // Filter out prereleases and drafts, then reverse to show newest first
  const validReleases = releases.filter(release => !release.prerelease && !release.draft).reverse();

  for (const release of validReleases) {
    const createdDate = new Date(release.created_at);
    const date = formatDate(createdDate);
    const releaseBody = transformReleaseBody(release.body);
    changelogBody += `## [${release.tag_name}] - ${date}\n\n${releaseBody}\n\n`;
  }

  return changelogBody;
}

/**
 * Generate changelog footer with release URLs
 * @param {Array} releases - Array of release objects
 * @returns {string} Changelog footer
 */
function generateChangelogFooter(releases) {
  let changelogFooter = '';

  // Filter out prereleases and drafts, then reverse to show newest first
  const validReleases = releases.filter(release => !release.prerelease && !release.draft).reverse();

  for (const release of validReleases) {
    changelogFooter += `[${release.tag_name}]: ${release.html_url}\n`;
  }

  return changelogFooter;
}

/**
 * Generate complete changelog from releases
 * @param {Array} releases - Array of release objects
 * @returns {string} Complete changelog
 */
function generateChangelog(releases) {
  const header = generateChangelogHeader();
  const body = generateChangelogBody(releases);
  const footer = generateChangelogFooter(releases);
  return header + body + footer;
}

/**
 * Fetch all releases from GitHub
 * @param {Object} github - GitHub API object
 * @param {Object} context - GitHub Actions context object
 * @returns {Promise<Array>} Array of release objects sorted by creation date
 */
async function fetchAllReleases(github, context) {
  let releases = [];
  let page = 1;
  const perPage = 100;
  let total = 0;

  do {
    const response = await github.rest.repos.listReleases({
      owner: context.repo.owner,
      repo: context.repo.repo,
      per_page: perPage,
      page: page
    });
    releases = releases.concat(response.data);
    total = response.data.length;
    page++;
  } while (total === perPage);

  // Sort releases by date created (oldest first)
  releases.sort((a, b) => {
    return new Date(a.created_at) - new Date(b.created_at);
  });

  return releases;
}

/**
 * Create an orphaned branch with the changelog file
 * @param {Object} github - GitHub API object
 * @param {Object} context - GitHub Actions context object
 * @param {string} changelogContent - Content of the changelog
 * @param {string} changelogBranch - Branch name to create
 * @param {string} changelogFile - File name for the changelog
 */
async function createOrphanedBranch(github, context, changelogContent, changelogBranch, changelogFile) {
  // Create a blob for the changelog content
  const blob = await github.rest.git.createBlob({
    owner: context.repo.owner,
    repo: context.repo.repo,
    content: changelogContent,
    encoding: 'utf-8'
  });

  // Create a tree with the changelog file
  const tree = await github.rest.git.createTree({
    owner: context.repo.owner,
    repo: context.repo.repo,
    tree: [{
      path: changelogFile,
      mode: '100644',
      type: 'blob',
      sha: blob.data.sha
    }]
  });

  // Create an orphaned commit (no parents)
  const commit = await github.rest.git.createCommit({
    owner: context.repo.owner,
    repo: context.repo.repo,
    message: `chore: create ${changelogFile}`,
    tree: tree.data.sha,
    parents: [] // Empty parents array for a truly orphaned commit
  });

  // Create a reference to the new branch
  await github.rest.git.createRef({
    owner: context.repo.owner,
    repo: context.repo.repo,
    ref: `refs/heads/${changelogBranch}`,
    sha: commit.data.sha
  });
}

/**
 * Update existing changelog file in branch
 * @param {Object} github - GitHub API object
 * @param {Object} context - GitHub Actions context object
 * @param {string} changelogContent - Content of the changelog
 * @param {string} changelogBranch - Branch name
 * @param {string} changelogFile - File name for the changelog
 */
async function updateChangelogFile(github, context, changelogContent, changelogBranch, changelogFile) {
  let sha = null;

  // Try to fetch the SHA of the existing file
  try {
    const fileData = await github.rest.repos.getContent({
      owner: context.repo.owner,
      repo: context.repo.repo,
      path: changelogFile,
      ref: changelogBranch
    });
    sha = fileData.data.sha;
  } catch (getFileError) {
    if (getFileError.status !== 404) {
      throw new Error(`Failed to fetch the file: ${getFileError.message}`);
    }
    // If 404, sha remains null and we'll create a new file
  }

  // Create or update the file
  await github.rest.repos.createOrUpdateFileContents({
    owner: context.repo.owner,
    repo: context.repo.repo,
    path: changelogFile,
    message: sha ? `chore: update ${changelogFile}` : `chore: create ${changelogFile}`,
    content: Buffer.from(changelogContent).toString('base64'),
    sha: sha, // if sha is null, it'll create a new file
    branch: changelogBranch
  });
}

/**
 * Main function to generate and publish changelog
 * @param {Object} params - Function parameters
 * @param {Object} params.github - GitHub API object
 * @param {Object} params.context - GitHub Actions context object
 * @param {Object} params.core - GitHub Actions core object
 */
async function generateReleaseChangelog({ github, context, core }) {
  // Get inputs
  const changelogBranch = process.env.changelog_branch || 'changelog';
  const changelogFile = process.env.changelog_file || 'CHANGELOG.md';

  console.log(`Generating changelog for ${context.repo.owner}/${context.repo.repo}`);
  console.log(`Branch: ${changelogBranch}`);
  console.log(`File: ${changelogFile}\n`);

  try {
    // Fetch all releases
    const releases = await fetchAllReleases(github, context);
    console.log(`Found ${releases.length} releases\n`);

    // Generate changelog
    const changelog = generateChangelog(releases);

    // Try to create orphaned branch or update existing branch
    try {
      await createOrphanedBranch(github, context, changelog, changelogBranch, changelogFile);
      console.log(`✅ Created new branch: ${changelogBranch}`);
    } catch (e) {
      if (e.status === 422 && e.message.includes("Reference already exists")) {
        console.log(`Branch ${changelogBranch} already exists, updating...`);
        await updateChangelogFile(github, context, changelog, changelogBranch, changelogFile);
        console.log(`✅ Updated ${changelogFile} in ${changelogBranch}`);
      } else {
        throw new Error(`Failed to create or update changelog: ${e.message}`);
      }
    }

    // Set output
    core.setOutput('changelog', changelog);
    console.log('\n✅ Changelog generation completed successfully!');
  } catch (error) {
    core.setFailed(`Action failed with error: ${error.message}`);
  }
}

module.exports = generateReleaseChangelog;
module.exports.formatDate = formatDate;
module.exports.transformReleaseBody = transformReleaseBody;
module.exports.generateChangelogHeader = generateChangelogHeader;
module.exports.generateChangelogBody = generateChangelogBody;
module.exports.generateChangelogFooter = generateChangelogFooter;
module.exports.generateChangelog = generateChangelog;
module.exports.fetchAllReleases = fetchAllReleases;
module.exports.createOrphanedBranch = createOrphanedBranch;
module.exports.updateChangelogFile = updateChangelogFile;
